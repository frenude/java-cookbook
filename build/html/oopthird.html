

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>10. 面对对象-下 &mdash; Java-Cookbook 0.1.1 文档</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="11. 异常" href="throw.html" />
    <link rel="prev" title="9. 面对对象-中" href="oopsecond.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Java-Cookbook
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="helloworld.html">1. 第一个<code class="docutils literal notranslate"><span class="pre">JAVA</span></code>程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="programmingspecification.html">2. 编程规范</a></li>
<li class="toctree-l1"><a class="reference internal" href="constant.html">3. 常量</a></li>
<li class="toctree-l1"><a class="reference internal" href="variable.html">4. 变量</a></li>
<li class="toctree-l1"><a class="reference internal" href="operator.html">5. 运算符</a></li>
<li class="toctree-l1"><a class="reference internal" href="processcontrol.html">6. 流程控制</a></li>
<li class="toctree-l1"><a class="reference internal" href="array.html">7. 数组</a></li>
<li class="toctree-l1"><a class="reference internal" href="oopfirst.html">8. 面向对象-上</a></li>
<li class="toctree-l1"><a class="reference internal" href="oopsecond.html">9. 面对对象-中</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">10. 面对对象-下</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#static">10.1. 关键字：<code class="docutils literal notranslate"><span class="pre">static</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">10.1.1. <code class="docutils literal notranslate"><span class="pre">static</span></code>:静态的</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">10.1.2. <code class="docutils literal notranslate"><span class="pre">static</span></code>修饰属性</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">10.1.3. <code class="docutils literal notranslate"><span class="pre">static</span></code>修饰方法：</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">10.1.4. 如何判定属性和方法应该使用static关键字：</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">10.1.5. 设计模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">10.1.6. 单例模式</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#main">10.2. <code class="docutils literal notranslate"><span class="pre">main()</span></code>的使用说明</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">10.2.1. <code class="docutils literal notranslate"><span class="pre">main()</span></code>说明:</a></li>
<li class="toctree-l3"><a class="reference internal" href="#string-args">10.2.2. 如何将控制台获取的数据传给形参：<code class="docutils literal notranslate"><span class="pre">String[]</span> <span class="pre">args</span></code>:</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">10.2.3. <code class="docutils literal notranslate"><span class="pre">main</span></code>方法解析</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id10">10.3. 类的结构：代码块</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id11">10.3.1. 类的成员之四：</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">10.3.2. 程序中成员变量赋值的执行顺序</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">10.3.3. 实例化子类对象时，构造器的加载顺序：</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#final">10.4. 关键字：<code class="docutils literal notranslate"><span class="pre">final</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id14">10.4.1. <code class="docutils literal notranslate"><span class="pre">final</span></code>：最终的</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">10.4.2. <code class="docutils literal notranslate"><span class="pre">final</span></code> 用来修饰一个类:</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id16">10.4.3. <code class="docutils literal notranslate"><span class="pre">final</span></code> 用来修饰方法：</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">10.4.4. <code class="docutils literal notranslate"><span class="pre">final</span></code> 用来修饰变量：</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#abstract">10.5. 关键字：<code class="docutils literal notranslate"><span class="pre">abstract</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id18">10.5.1. <code class="docutils literal notranslate"><span class="pre">abstract</span></code>: 抽象的</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id19">10.5.2. <code class="docutils literal notranslate"><span class="pre">abstract</span></code>修饰类：</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id20">10.5.3. <code class="docutils literal notranslate"><span class="pre">abstract</span></code>修饰方法：</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id21">10.5.4. 模板方法的设计模式</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#interface">10.6. 关键字：<code class="docutils literal notranslate"><span class="pre">interface</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id22">10.6.1. <code class="docutils literal notranslate"><span class="pre">interface</span></code>:接口</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id23">10.6.2. 举例</a></li>
<li class="toctree-l3"><a class="reference internal" href="#java8">10.6.3. <code class="docutils literal notranslate"><span class="pre">Java8</span></code>中关于接口的新规范</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id24">10.6.4. 匿名对象 、匿名接口</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id25">10.6.5. 代理模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id26">10.6.6. 工厂的设计模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id27">10.6.7. 接口和抽象类之间的区别：</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id28">10.7. 类的结构：内部类</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id29">10.7.1. 内部类：类的第五个成员</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id30">10.7.2. 内部类代码理解</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id31">10.7.3. 如何在成员内部类中调用外部类的结构？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id32">10.7.4. 局部内部类的使用</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id33">10.7.5. <strong>成员内部类和局部内部类，在编译以后，都会生成字节码文件。</strong></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#native">10.8. 关键字:<code class="docutils literal notranslate"><span class="pre">native</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id34">10.8.1. native 关键的理解</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="throw.html">11. 异常</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Java-Cookbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">10. </span>面对对象-下</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/oopthird.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1><span class="section-number">10. </span>面对对象-下<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="static">
<h2><span class="section-number">10.1. </span>关键字：<code class="docutils literal notranslate"><span class="pre">static</span></code><a class="headerlink" href="#static" title="永久链接至标题">¶</a></h2>
<div class="section" id="id2">
<h3><span class="section-number">10.1.1. </span><code class="docutils literal notranslate"><span class="pre">static</span></code>:静态的<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>作用：</p>
<ul>
<li><p>主要用来修饰类的内部结构</p></li>
</ul>
</li>
<li><p>可以用来修饰的结构</p>
<ul>
<li><p>属性</p></li>
<li><p>方法</p></li>
<li><p>代码块</p></li>
<li><p>内部类</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id3">
<h3><span class="section-number">10.1.2. </span><code class="docutils literal notranslate"><span class="pre">static</span></code>修饰属性<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>静态变量（或类变量）</p></li>
<li><p>属性，是否使用<code class="docutils literal notranslate"><span class="pre">static</span></code>修饰，又分为：</p>
<ul>
<li><p>静态属性(<code class="docutils literal notranslate"><span class="pre">python</span> </code>中又称为类属性 是定义在类内部的可以通过类.属性直接获取)</p></li>
<li><p>非静态属性(实例变量)(<code class="docutils literal notranslate"><span class="pre">python</span> </code>中又称为实例属性 是定义在类中<code class="docutils literal notranslate"><span class="pre">__init__</span></code>方法中的，需要实例化后才能或取)</p></li>
</ul>
</li>
<li><p>实例变量：创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</p></li>
<li><p>静态变量：创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">static</span></code>修饰属性的其他说明：</p>
<ul>
<li><p>静态变量随着类的加载而加载。可以通过<code class="docutils literal notranslate"><span class="pre">类.静态变量</span></code>的方式进行调用</p></li>
<li><p>静态变量的加载要早于对象的创建。</p></li>
<li><p>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</p></li>
</ul>
</li>
<li><p>区别(类与对象直接<code class="docutils literal notranslate"><span class="pre">.</span></code>获取变量)</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th></th>
<th>类变量</th>
<th>实例变量</th>
</tr>
</thead>
<tbody>
<tr>
<td>类</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>对象</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody>
</table><ul>
<li><p>类变量和实例变量的内存解析</p>
<p><img alt="类变量和实例变量的内存解析" src="_images/Memoryparsingclassvariablesandinstancevariables.gif" /></p>
</li>
</ul>
</div>
<div class="section" id="id4">
<h3><span class="section-number">10.1.3. </span><code class="docutils literal notranslate"><span class="pre">static</span></code>修饰方法：<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>静态方法、类方法</p></li>
<li><p>随着类的加载而加载，可以通过<code class="docutils literal notranslate"><span class="pre">类.静态方法</span></code>的方式进行调用</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th></th>
<th>静态方法</th>
<th>非静态方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>类</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>对象</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody>
</table><ul class="simple">
<li><p>static的注意点：</p>
<ul>
<li><p>在静态的方法内，不能使用this关键字、super关键字</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id5">
<h3><span class="section-number">10.1.4. </span>如何判定属性和方法应该使用static关键字：<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>关于属性</p>
<ul>
<li><p>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</p></li>
<li><p>类中的常量也常常声明为static</p></li>
</ul>
</li>
<li><p>关于方法</p>
<ul>
<li><p>操作静态属性的方法，通常设置为static的</p></li>
<li><p>工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id6">
<h3><span class="section-number">10.1.5. </span>设计模式<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>设计模式是在大量的实践中总结和理论化之后优的代码结构、编程风格、以及解决问题的思考方式。</p></li>
<li><p>常用设计模式  — 23种经典的设计模式  GOF</p></li>
<li><p>创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p></li>
<li><p>结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p></li>
<li><p>行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p></li>
</ul>
</div>
<div class="section" id="id7">
<h3><span class="section-number">10.1.6. </span>单例模式<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p></li>
<li><p>分类</p>
<ul>
<li><p>懒汉式</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="c1">// 懒汉式 (非线程安全)</span>
<span class="kd">class</span> <span class="nc">Order</span><span class="p">{</span>

	<span class="c1">//1.私化类的构造器</span>
	<span class="kd">private</span> <span class="nf">Order</span><span class="p">(){</span>

	<span class="p">}</span>

	<span class="c1">//2.声明当前类对象，没初始化</span>
	<span class="c1">//4.此对象也必须声明为static的</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="n">Order</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

	<span class="c1">//3.声明public、static的返回当前类对象的方法</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="n">Order</span> <span class="nf">getInstance</span><span class="p">(){</span>

		<span class="k">if</span><span class="p">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="p">){</span>

			<span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Order</span><span class="p">();</span>

		<span class="p">}</span>
		<span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>饿汉式</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="c1">// 饿汉式1：</span>
<span class="kd">class</span> <span class="nc">Bank</span><span class="p">{</span>

	<span class="c1">//1.私化类的构造器</span>
	<span class="kd">private</span> <span class="nf">Bank</span><span class="p">(){</span>

	<span class="p">}</span>

	<span class="c1">//2.内部创建类的对象</span>
	<span class="c1">//4.要求此对象也必须声明为静态的</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="n">Bank</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bank</span><span class="p">();</span>

	<span class="c1">//3.提供公共的静态的方法，返回类的对象</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="n">Bank</span> <span class="nf">getInstance</span><span class="p">(){</span>
		<span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 饿汉式2：使用了静态代码块</span>
<span class="kd">class</span> <span class="nc">Order</span><span class="p">{</span>

	<span class="c1">//1.私化类的构造器</span>
	<span class="kd">private</span> <span class="nf">Order</span><span class="p">(){</span>

	<span class="p">}</span>

	<span class="c1">//2.声明当前类对象，没初始化</span>
	<span class="c1">//4.此对象也必须声明为static的</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="n">Order</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

	<span class="kd">static</span><span class="p">{</span>
		<span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Order</span><span class="p">();</span>
 <span class="p">}</span>

	<span class="c1">//3.声明public、static的返回当前类对象的方法</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="n">Order</span> <span class="nf">getInstance</span><span class="p">(){</span>
		<span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>两种方式的对比：</p>
<ul class="simple">
<li><p>饿汉式：</p>
<ul>
<li><p>坏处：对象加载时间过长。</p></li>
<li><p>好处：饿汉式是线程安全的</p></li>
</ul>
</li>
<li><p>懒汉式：</p>
<ul>
<li><p>好处：延迟对象的创建。</p></li>
<li><p>目前的写法坏处：线程不安全。</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="main">
<h2><span class="section-number">10.2. </span><code class="docutils literal notranslate"><span class="pre">main()</span></code>的使用说明<a class="headerlink" href="#main" title="永久链接至标题">¶</a></h2>
<div class="section" id="id8">
<h3><span class="section-number">10.2.1. </span><code class="docutils literal notranslate"><span class="pre">main()</span></code>说明:<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">main()</span></code>方法作为程序的入口</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">main()</span></code>方法也是一个普通的静态方法</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">main()</span></code>方法可以作为我们与控制台交互的方式。（之前：使用Scanner）</p></li>
</ul>
</div>
<div class="section" id="string-args">
<h3><span class="section-number">10.2.2. </span>如何将控制台获取的数据传给形参：<code class="docutils literal notranslate"><span class="pre">String[]</span> <span class="pre">args</span></code>:<a class="headerlink" href="#string-args" title="永久链接至标题">¶</a></h3>
<p>运行时：<code class="docutils literal notranslate"><span class="pre">java</span> <span class="pre">类名</span> <span class="pre">参数Strings列表</span> </code></p>
</div>
<div class="section" id="id9">
<h3><span class="section-number">10.2.3. </span><code class="docutils literal notranslate"><span class="pre">main</span></code>方法解析<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">){</span>
    <span class="c1">//方法体</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>权限修饰符：<code class="docutils literal notranslate"><span class="pre">private</span> <span class="pre">,缺省,</span> <span class="pre">protected</span> <span class="pre">,pubilc</span> </code>—-&gt;封装性</p></li>
<li><p>修饰符：<code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">,</span> <span class="pre">final</span> <span class="pre">,</span> <span class="pre">abstract</span> <span class="pre">,native</span> </code>可以用来修饰方法</p></li>
<li><p>返回值类型： <code class="docutils literal notranslate"><span class="pre">void</span></code>无返回值 / 有返回值 –&gt;return</p></li>
<li><p>方法名：需要满足标识符命名的规则、规范。<code class="docutils literal notranslate"><span class="pre">见名知意</span></code></p></li>
<li><p>形参列表：重载 vs 重写；参数的值传递机制；体现对象的多态性</p></li>
<li><p>方法体：来体现方法的功能</p></li>
</ul>
</div>
</div>
<div class="section" id="id10">
<h2><span class="section-number">10.3. </span>类的结构：代码块<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<div class="section" id="id11">
<h3><span class="section-number">10.3.1. </span>类的成员之四：<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>代码块(初始化块)</p></li>
<li><p>作用：用来初始化类、对象的信息</p></li>
<li><p>分类(代码块要是使用修饰符，只能使用<code class="docutils literal notranslate"><span class="pre">static</span></code>):</p>
<ul>
<li><p>静态代码块</p>
<ol class="simple">
<li><p>内部可以输出语句</p></li>
<li><p>随着类的加载而执行,而且只执行一次</p></li>
<li><p>作用：初始化类的信息</p></li>
<li><p>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</p></li>
<li><p>静态代码块的执行要优先于非静态代码块的执行</p></li>
<li><p>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</p></li>
</ol>
</li>
<li><p>非静态代码块</p>
<ul>
<li><p>内部可以输出语句</p></li>
<li><p>随着对象的创建而执行</p></li>
<li><p>每创建一个对象，就执行一次非静态代码块</p></li>
<li><p>作用：可以在创建对象时，对对象的属性等进行初始化</p></li>
<li><p>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</p></li>
<li><p>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id12">
<h3><span class="section-number">10.3.2. </span>程序中成员变量赋值的执行顺序<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<ol class="simple">
<li><p>声明成员变量的默认初始化</p></li>
<li><p>显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）</p></li>
<li><p>构造器再对成员进行初始化操作</p></li>
<li><p>通过”对象.属性”或”对象.方法”的方式，可多次给属性赋值</p></li>
</ol>
</div>
<div class="section" id="id13">
<h3><span class="section-number">10.3.3. </span>实例化子类对象时，构造器的加载顺序：<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>由父及子，静态先行。</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Root</span><span class="p">{</span>
    <span class="kd">static</span><span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Root的静态初始化块&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Root的普通初始化块&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="nf">Root</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Root的无参数的构造器&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nc">Mid</span> <span class="kd">extends</span> <span class="n">Root</span><span class="p">{</span>
    <span class="kd">static</span><span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Mid的静态初始化块&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Mid的普通初始化块&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="nf">Mid</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Mid的无参数的构造器&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="nf">Mid</span><span class="p">(</span><span class="n">String</span> <span class="n">msg</span><span class="p">){</span>
        <span class="c1">//通过this调用同一类中重载的构造器</span>
        <span class="k">this</span><span class="p">();</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Mid的带参数构造器，其参数值：&quot;</span>
                <span class="o">+</span> <span class="n">msg</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nc">Leaf</span> <span class="kd">extends</span> <span class="n">Mid</span><span class="p">{</span>
    <span class="kd">static</span><span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Leaf的静态初始化块&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Leaf的普通初始化块&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="nf">Leaf</span><span class="p">(){</span>
        <span class="c1">//通过super调用父类中有一个字符串参数的构造器</span>
        <span class="kd">super</span><span class="p">(</span><span class="s">&quot;啦啦啦&quot;</span><span class="p">);</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Leaf的构造器&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">){</span>
        <span class="k">new</span> <span class="n">Leaf</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*Root的静态初始化块</span>
<span class="cm">Mid的静态初始化块</span>
<span class="cm">Leaf的静态初始化块</span>
<span class="cm">Root的普通初始化块</span>
<span class="cm">Root的无参数的构造器</span>
<span class="cm">Mid的普通初始化块</span>
<span class="cm">Mid的无参数的构造器</span>
<span class="cm">Mid的带参数构造器，其参数值：啦啦啦</span>
<span class="cm">Leaf的普通初始化块</span>
<span class="cm">Leaf的构造器*/</span>
</pre></div>
</div>
</li>
<li><p>案例二</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Father</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;11111111111&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;22222222222&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="nf">Father</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;33333333333&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Son</span> <span class="kd">extends</span> <span class="n">Father</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;44444444444&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;55555555555&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="nf">Son</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;66666666666&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 由父及子 静态先行</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;77777777777&quot;</span><span class="p">);</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;************************&quot;</span><span class="p">);</span>
        <span class="k">new</span> <span class="n">Son</span><span class="p">();</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;************************&quot;</span><span class="p">);</span>
        <span class="k">new</span> <span class="n">Son</span><span class="p">();</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;************************&quot;</span><span class="p">);</span>
        <span class="k">new</span> <span class="n">Father</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  11111111111</span>
<span class="cm">  44444444444</span>
<span class="cm">  77777777777</span>
<span class="cm">  ************************</span>
<span class="cm">  22222222222</span>
<span class="cm">  33333333333</span>
<span class="cm">  55555555555</span>
<span class="cm">  66666666666</span>
<span class="cm">  ************************</span>
<span class="cm">  22222222222</span>
<span class="cm">  33333333333</span>
<span class="cm">  55555555555</span>
<span class="cm">  66666666666</span>
<span class="cm">  ************************</span>
<span class="cm">  22222222222</span>
<span class="cm">  33333333333*/</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="final">
<h2><span class="section-number">10.4. </span>关键字：<code class="docutils literal notranslate"><span class="pre">final</span></code><a class="headerlink" href="#final" title="永久链接至标题">¶</a></h2>
<div class="section" id="id14">
<h3><span class="section-number">10.4.1. </span><code class="docutils literal notranslate"><span class="pre">final</span></code>：最终的<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>可以用来修饰：类、方法、变量</p></li>
</ul>
</div>
<div class="section" id="id15">
<h3><span class="section-number">10.4.2. </span><code class="docutils literal notranslate"><span class="pre">final</span></code> 用来修饰一个类:<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>此类不能被其他类所继承。</p></li>
<li><p>比如：<code class="docutils literal notranslate"><span class="pre">String</span></code>类、<code class="docutils literal notranslate"><span class="pre">System</span></code>类、<code class="docutils literal notranslate"><span class="pre">StringBuffer</span></code>类</p></li>
</ul>
</div>
<div class="section" id="id16">
<h3><span class="section-number">10.4.3. </span><code class="docutils literal notranslate"><span class="pre">final</span></code> 用来修饰方法：<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>表明此方法不可以被重写</p></li>
<li><p>比如：<code class="docutils literal notranslate"><span class="pre">Object</span></code>类中<code class="docutils literal notranslate"><span class="pre">getClass()</span></code>;</p></li>
</ul>
</div>
<div class="section" id="id17">
<h3><span class="section-number">10.4.4. </span><code class="docutils literal notranslate"><span class="pre">final</span></code> 用来修饰变量：<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>此时的<code class="docutils literal notranslate"><span class="pre">变量</span></code>就称为是一个<code class="docutils literal notranslate"><span class="pre">常量</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">final</span></code>修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">final</span></code>修饰局部变量：</p>
<ul>
<li><p>尤其是使用<code class="docutils literal notranslate"><span class="pre">final</span></code>修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</p></li>
</ul>
</li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">final</span></code> 用来修饰属性：全局常量</strong></p></li>
</ul>
</div>
</div>
<div class="section" id="abstract">
<h2><span class="section-number">10.5. </span>关键字：<code class="docutils literal notranslate"><span class="pre">abstract</span></code><a class="headerlink" href="#abstract" title="永久链接至标题">¶</a></h2>
<div class="section" id="id18">
<h3><span class="section-number">10.5.1. </span><code class="docutils literal notranslate"><span class="pre">abstract</span></code>: 抽象的<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>可以用来修饰：类、方法</p></li>
</ul>
</div>
<div class="section" id="id19">
<h3><span class="section-number">10.5.2. </span><code class="docutils literal notranslate"><span class="pre">abstract</span></code>修饰类：<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>抽象类</p></li>
<li><p>此类不能实例化</p></li>
<li><p>抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</p></li>
<li><p>抽象的使用前提：继承性</p></li>
</ul>
</div>
<div class="section" id="id20">
<h3><span class="section-number">10.5.3. </span><code class="docutils literal notranslate"><span class="pre">abstract</span></code>修饰方法：<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>抽象方法</p></li>
<li><p>抽象方法只方法的声明，没方法体</p></li>
<li><p>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</p></li>
<li><p>若子类重写了父类中的所的抽象方法后，此子类方可实例化；若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用<code class="docutils literal notranslate"><span class="pre">abstract</span></code>修饰</p></li>
<li><p>注意:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">abstract</span></code>不能用来修饰：属性、构造器等结构</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abstract</span></code>不能用来修饰私方法、静态方法、final的方法、final的类</p></li>
</ul>
</li>
<li><p>举例</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">GeometricObject</span><span class="p">{</span>
	<span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">double</span> <span class="nf">findArea</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Circle</span> <span class="kd">extends</span> <span class="n">GeometricObject</span><span class="p">{</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">radius</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">findArea</span><span class="p">(){</span>
            <span class="k">return</span> <span class="mf">3.14</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="id21">
<h3><span class="section-number">10.5.4. </span>模板方法的设计模式<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p></li>
<li><p>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p></li>
<li><p>举例：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Template</span><span class="p">{</span>
	<span class="c1">//计算某段代码执行所需要花费的时间</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">spendTime</span><span class="p">(){</span>
		<span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span>
		<span class="k">this</span><span class="p">.</span><span class="na">code</span><span class="p">();</span><span class="c1">//不确定的部分、易变的部分</span>
		<span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span>
		<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;花费的时间为：&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">));</span>	
	<span class="p">}</span>
	<span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">code</span><span class="p">();</span>

<span class="p">}</span>

<span class="kd">class</span> <span class="nc">SubTemplate</span> <span class="kd">extends</span> <span class="n">Template</span><span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">code</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
			<span class="kt">boolean</span> <span class="n">isFlag</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">Math</span><span class="p">.</span><span class="na">sqrt</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>				
				<span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
					<span class="n">isFlag</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span><span class="p">(</span><span class="n">isFlag</span><span class="p">){</span>
				<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>	
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：</p></li>
<li><p>数据库访问的封装</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Junit</span></code>单元测试</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">JavaWeb</span></code>的<code class="docutils literal notranslate"><span class="pre">Servlet</span></code>中关于<code class="docutils literal notranslate"><span class="pre">doGet/doPost</span></code>方法调用</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Hibernate</span></code>中模板程序</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Spring</span></code>中<code class="docutils literal notranslate"><span class="pre">JDBCTemlate</span></code>、<code class="docutils literal notranslate"><span class="pre">HibernateTemplate</span></code>等</p></li>
</ul>
</div>
</div>
<div class="section" id="interface">
<h2><span class="section-number">10.6. </span>关键字：<code class="docutils literal notranslate"><span class="pre">interface</span></code><a class="headerlink" href="#interface" title="永久链接至标题">¶</a></h2>
<div class="section" id="id22">
<h3><span class="section-number">10.6.1. </span><code class="docutils literal notranslate"><span class="pre">interface</span></code>:接口<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h3>
<ol class="simple">
<li><p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须能…”的思想。继承是一个”是不是”的关系，而接口实现则是 “能不能” 的关系。</p></li>
<li><p>接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都要遵守。</p></li>
<li><p>接口使用<code class="docutils literal notranslate"><span class="pre">interface</span></code>来定义</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Java</span></code>中，接口和类是并列的两个结构</p></li>
<li><p>接口中的成员</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">JDK7</span></code>及以前：只能定义全局常量和抽象方法</p>
<ul>
<li><p>全局常量：<code class="docutils literal notranslate"><span class="pre">public</span> <span class="pre">static</span> <span class="pre">final</span></code>但是书写时，可以省略不写</p></li>
<li><p>抽象方法：<code class="docutils literal notranslate"><span class="pre">public</span> <span class="pre">abstract</span></code></p></li>
</ul>
</li>
<li><p>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略)</p></li>
</ul>
</li>
<li><p><strong>接口中不能定义构造器的！意味着接口不可以实例化</strong></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Java</span></code>开发中，接口通过让类去实现(<code class="docutils literal notranslate"><span class="pre">implements</span></code>)的方式来使用</p>
<ul class="simple">
<li><p>如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化</p></li>
<li><p>如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Java</span></code>类可以实现多个接口   —&gt;弥补了<code class="docutils literal notranslate"><span class="pre">Java</span></code>单继承性的局限性</p>
<ul class="simple">
<li><p>格式：<code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">AA</span> <span class="pre">extends</span> <span class="pre">BB</span> <span class="pre">implements</span> <span class="pre">CC,DD,EE</span></code></p></li>
</ul>
</li>
<li><p>接口与接口之间可以继承，而且可以多继承</p></li>
<li><p>接口的具体使用，体现多态性</p></li>
</ol>
</div>
<div class="section" id="id23">
<h3><span class="section-number">10.6.2. </span>举例<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h3>
<p><img alt="image-20201208150400026" src="_images/interface.png" /></p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Computer</span><span class="p">{</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">transferData</span><span class="p">(</span><span class="n">USB</span> <span class="n">usb</span><span class="p">){</span><span class="c1">//USB usb = new Flash();</span>
		<span class="n">usb</span><span class="p">.</span><span class="na">start</span><span class="p">();</span>
		
		<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;具体传输数据的细节&quot;</span><span class="p">);</span>
		
		<span class="n">usb</span><span class="p">.</span><span class="na">stop</span><span class="p">();</span>
	<span class="p">}</span>
	
	
<span class="p">}</span>

<span class="kd">interface</span> <span class="nc">USB</span><span class="p">{</span>
	<span class="c1">//常量：定义了长、宽、最大最小的传输速度等</span>
	
	<span class="kt">void</span> <span class="nf">start</span><span class="p">();</span>
	
	<span class="kt">void</span> <span class="nf">stop</span><span class="p">();</span>
	
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Flash</span> <span class="kd">implements</span> <span class="n">USB</span><span class="p">{</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;U盘开启工作&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;U盘结束工作&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Printer</span> <span class="kd">implements</span> <span class="n">USB</span><span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;打印机开启工作&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;打印机结束工作&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	
<span class="p">}</span>
</pre></div>
</div>
<p>总结：</p>
<ol class="simple">
<li><p>接口使用上也满足多态性</p></li>
<li><p>接口，实际上就是定义了一种规范</p></li>
<li><p>开发中，体会面向接口编程！</p></li>
</ol>
</div>
<div class="section" id="java8">
<h3><span class="section-number">10.6.3. </span><code class="docutils literal notranslate"><span class="pre">Java8</span></code>中关于接口的新规范<a class="headerlink" href="#java8" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>静态方法：使用 <code class="docutils literal notranslate"><span class="pre">static</span> </code>关键字修饰。可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像<code class="docutils literal notranslate"><span class="pre">Collection/Collections</span></code>或者<code class="docutils literal notranslate"><span class="pre">Path/Paths</span></code>这样成对的接口和类。</p></li>
<li><p>默认方法：默认方法使用 <code class="docutils literal notranslate"><span class="pre">default</span></code> 关键字修饰。可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性。比如：<code class="docutils literal notranslate"><span class="pre">java</span> <span class="pre">8</span> <span class="pre">API</span></code>中对<code class="docutils literal notranslate"><span class="pre">Collection、List、Comparator</span></code>等接口提供了丰富的默认方法。</p></li>
<li><p>接口中定义的静态方法，只能通过接口来调用。</p></li>
<li><p>通过实现类的对象，可以调用接口中的默认方法。</p>
<ul class="simple">
<li><p>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</p></li>
</ul>
</li>
<li><p>如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt;类优先原则</p></li>
<li><p>如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</p>
<ul class="simple">
<li><p>那么在实现类没重写此方法的情况下，报错。–&gt;接口冲突。</p></li>
<li><p>这就需要我们必须在实现类中重写此方法</p></li>
</ul>
</li>
<li><p>如何在子类(或实现类)的方法中调用父类、接口中被重写的方法。</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span>	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">myMethod</span><span class="p">(){</span>
		<span class="n">method3</span><span class="p">();</span><span class="c1">//调用自己定义的重写的方法</span>
		<span class="kd">super</span><span class="p">.</span><span class="na">method3</span><span class="p">();</span><span class="c1">//调用的是父类中声明的</span>
		<span class="c1">//调用接口中的默认方法</span>
		<span class="n">CompareA</span><span class="p">.</span><span class="na">super</span><span class="p">.</span><span class="na">method3</span><span class="p">();</span>
		<span class="n">CompareB</span><span class="p">.</span><span class="na">super</span><span class="p">.</span><span class="na">method3</span><span class="p">();</span>
	<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="id24">
<h3><span class="section-number">10.6.4. </span>匿名对象 、匿名接口<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h3>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Interface</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// java8 interface 知识点1：接口中定义的静态方法，只能通过接口来调用</span>
        <span class="n">USB</span><span class="p">.</span><span class="na">method1</span><span class="p">();</span>
        <span class="n">Flash</span> <span class="n">flash1</span> <span class="o">=</span><span class="k">new</span> <span class="n">Flash</span><span class="p">();</span>
        <span class="c1">// 知识点2：通过实现类的对象，可以调用接口中的默认方法。</span>
        <span class="c1">// 如果实现类重写了接口中的默认方法，调用时调用的是重写后的方法</span>
        <span class="n">flash1</span><span class="p">.</span><span class="na">method2</span><span class="p">();</span>
        <span class="c1">// 知识点3：如果子类(实现类)继承了父类和实现了接口中声明的同名同参数默认方法</span>
        <span class="c1">// 那么子类在没有重写的情况下，默认调用的是父类中的同名同参数方法 ----&gt; 类优先原则</span>
        <span class="c1">// 知识点4:如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</span>
        <span class="c1">// 那么在实现类没有重写此方法的情况下，报错。--&gt;接口冲突</span>
        <span class="c1">// 解决方法：重写</span>
        <span class="c1">// 知识点5：</span>
        <span class="c1">// 子类中定义方法 调用重写的方法 method();</span>
        <span class="c1">// 调用父类的方法 super.method();</span>
        <span class="c1">// 调用接口中的默认方法。接口名.super.method();</span>

        <span class="n">Computer</span> <span class="n">com</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Computer</span><span class="p">();</span>

        <span class="c1">// 1.0 创建了接口的非匿名实现类的非匿名对象</span>
        <span class="n">Flash</span> <span class="n">flash</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Flash</span><span class="p">();</span>
        <span class="n">com</span><span class="p">.</span><span class="na">transferData</span><span class="p">(</span><span class="n">flash</span><span class="p">);</span>
        <span class="c1">// 2.0 创建了接口的非匿名实现类的匿名对象</span>
        <span class="n">com</span><span class="p">.</span><span class="na">transferData</span><span class="p">(</span><span class="k">new</span> <span class="n">Printer</span><span class="p">());</span>
        <span class="c1">// 3.0 创建了接口的匿名实现类的非匿名对象</span>
        <span class="n">USB</span> <span class="n">phone</span> <span class="o">=</span> <span class="k">new</span> <span class="n">USB</span><span class="p">(){</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;手机开始工作&quot;</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;手机结束工作&quot;</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">};</span>
        <span class="n">com</span><span class="p">.</span><span class="na">transferData</span><span class="p">(</span><span class="n">phone</span><span class="p">);</span>
        <span class="c1">// 4.0 创建了接口的匿名实现类的匿名对象</span>
        <span class="n">com</span><span class="p">.</span><span class="na">transferData</span><span class="p">(</span><span class="k">new</span> <span class="n">USB</span><span class="p">(){</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;MP3开始工作&quot;</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
                <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;MP3结束工作&quot;</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Computer</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">transferData</span><span class="p">(</span><span class="n">USB</span> <span class="n">usb</span><span class="p">)</span> <span class="p">{</span><span class="c1">//USB usb = new Flash();</span>
        <span class="n">usb</span><span class="p">.</span><span class="na">start</span><span class="p">();</span>

        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;具体传输数据的细节&quot;</span><span class="p">);</span>

        <span class="n">usb</span><span class="p">.</span><span class="na">stop</span><span class="p">();</span>
    <span class="p">}</span>


<span class="p">}</span>

<span class="kd">interface</span> <span class="nc">USB</span> <span class="p">{</span>
    <span class="c1">//常量：定义了长、宽、最大最小的传输速度等</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method1</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;USB_static_method1&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">default</span> <span class="kt">void</span> <span class="nf">method2</span><span class="p">(){</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;USB_default_method2&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">start</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">stop</span><span class="p">();</span>

<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Flash</span> <span class="kd">implements</span> <span class="n">USB</span> <span class="p">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;U盘开启工作&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;U盘结束工作&quot;</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Printer</span> <span class="kd">implements</span> <span class="n">USB</span> <span class="p">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;打印机开启工作&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;打印机结束工作&quot;</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h3><span class="section-number">10.6.5. </span>代理模式<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h3>
<ul>
<li><p>代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。</p></li>
<li><p>举例：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">interface</span> <span class="nc">NetWork</span><span class="p">{</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">browse</span><span class="p">();</span>

<span class="p">}</span>

<span class="c1">//被代理类</span>
<span class="kd">class</span> <span class="nc">Server</span> <span class="kd">implements</span> <span class="n">NetWork</span><span class="p">{</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">browse</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;真实的服务器访问网络&quot;</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>
<span class="c1">//代理类</span>
<span class="kd">class</span> <span class="nc">ProxyServer</span> <span class="kd">implements</span> <span class="n">NetWork</span><span class="p">{</span>

	<span class="kd">private</span> <span class="n">NetWork</span> <span class="n">work</span><span class="p">;</span>

	<span class="kd">public</span> <span class="nf">ProxyServer</span><span class="p">(</span><span class="n">NetWork</span> <span class="n">work</span><span class="p">){</span>
		<span class="k">this</span><span class="p">.</span><span class="na">work</span> <span class="o">=</span> <span class="n">work</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">check</span><span class="p">(){</span>
		<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;联网之前的检查工作&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">browse</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">check</span><span class="p">();</span>
		<span class="n">work</span><span class="p">.</span><span class="na">browse</span><span class="p">();</span>
	<span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>应用场景：</p>
<ul class="simple">
<li><p>安全代理：屏蔽对真实角色的直接访问。</p></li>
<li><p>远程代理：通过代理类处理远程方法调用（RMI）</p></li>
<li><p>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</p></li>
</ul>
</li>
<li><p>分类</p>
<ul class="simple">
<li><p>静态代理（静态定义代理类）</p></li>
<li><p>动态代理（动态生成代理类）</p></li>
<li><p>JDK自带的动态代理，需要反射等知识</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id26">
<h3><span class="section-number">10.6.6. </span>工厂的设计模式<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p></li>
<li><p>具体模式</p>
<ul>
<li><p>简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）</p></li>
<li><p>工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品)</p></li>
<li><p>抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id27">
<h3><span class="section-number">10.6.7. </span>接口和抽象类之间的区别：<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>区别点</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>包含抽象方法的类</td>
<td>主要是抽象方法和全局常量的集合</td>
</tr>
<tr>
<td>组成</td>
<td>构造方法、抽象方法、普通方法、常量、变量</td>
<td>常量、抽象方法、(jdk8.0:默认方法、静态方法)</td>
</tr>
<tr>
<td>使用</td>
<td>子类继承抽象类(extends)</td>
<td>子类实现接口(implements)</td>
</tr>
<tr>
<td>关系</td>
<td>抽象类可以实现多个接口</td>
<td>接口不能继承抽象类，但允许继承多个接口</td>
</tr>
<tr>
<td>设计模式</td>
<td>模板方法</td>
<td>简单工厂、工厂方法、代理模式</td>
</tr>
<tr>
<td>对象</td>
<td>都通过对象的多态性产生实例化对象</td>
<td>都通过对象的多态性产生实例化对象</td>
</tr>
<tr>
<td>局限</td>
<td>抽象类有单继承的局限</td>
<td>接口没有此局限</td>
</tr>
<tr>
<td>实际</td>
<td>作为一个模板</td>
<td>是作为一个标准或是表示一种能力</td>
</tr>
<tr>
<td>选择</td>
<td>如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限</td>
<td>如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限</td>
</tr>
</tbody>
</table></div>
</div>
<div class="section" id="id28">
<h2><span class="section-number">10.7. </span>类的结构：内部类<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h2>
<div class="section" id="id29">
<h3><span class="section-number">10.7.1. </span>内部类：类的第五个成员<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Java</span></code>中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类.</p></li>
<li><p>内部类的分类：</p>
<ul>
<li><p>成员内部类（静态、非静态 ）</p></li>
<li><p>局部内部类(方法内、代码块内、构造器内)</p></li>
</ul>
</li>
<li><p>成员内部类的理解：</p>
<ul>
<li><p>一方面，作为外部类的成员：</p>
<ul>
<li><p>调用外部类的结构</p></li>
<li><p>可以被<code class="docutils literal notranslate"><span class="pre">static</span></code>修饰</p></li>
<li><p>可以被4种不同的权限修饰</p></li>
</ul>
</li>
<li><p>另一方面，作为一个类：</p>
<ul>
<li><p>类内可以定义属性、方法、构造器等</p></li>
<li><p>可以被<code class="docutils literal notranslate"><span class="pre">final</span></code>修饰，表示此类不能被继承。言外之意，不使用<code class="docutils literal notranslate"><span class="pre">final</span></code>，就可以被继承</p></li>
<li><p>可以被<code class="docutils literal notranslate"><span class="pre">abstract</span></code>修饰</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id30">
<h3><span class="section-number">10.7.2. </span>内部类代码理解<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h3>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InnerClass</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 创建(静态成员内部类)</span>
        <span class="n">Zoo</span><span class="p">.</span><span class="na">Monkey</span> <span class="n">monkey</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Zoo</span><span class="p">.</span><span class="na">Monkey</span><span class="p">();</span>
        <span class="n">monkey</span><span class="p">.</span><span class="na">climb</span><span class="p">();</span>
        <span class="c1">// 创建(非静态成员内部类)</span>
        <span class="n">Zoo</span> <span class="n">zoo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Zoo</span><span class="p">();</span>
        <span class="n">Zoo</span><span class="p">.</span><span class="na">Bird</span> <span class="n">bird</span> <span class="o">=</span> <span class="n">zoo</span><span class="p">.</span><span class="na">new</span> <span class="nf">Bird</span><span class="p">(</span><span class="s">&quot;麻雀&quot;</span><span class="p">);</span>
        <span class="n">bird</span><span class="p">.</span><span class="na">sing</span><span class="p">();</span>
        <span class="n">bird</span><span class="p">.</span><span class="na">display</span><span class="p">(</span><span class="s">&quot;黄鹂&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Zoo</span> <span class="p">{</span>
    <span class="n">String</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">String</span> <span class="n">kinds</span><span class="p">;</span>

    <span class="kd">public</span> <span class="nf">Zoo</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="nf">Zoo</span><span class="p">(</span><span class="n">String</span> <span class="n">name</span><span class="p">,</span> <span class="n">String</span> <span class="n">kinds</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 局部内部类 -- 构造器</span>
        <span class="k">this</span><span class="p">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="na">kinds</span> <span class="o">=</span> <span class="n">kinds</span><span class="p">;</span>
        <span class="kd">class</span> <span class="nc">B</span> <span class="p">{</span>

        <span class="p">}</span>
    <span class="p">}</span>

    <span class="p">{</span>
        <span class="c1">// 局部内部类-&gt;代码块</span>
        <span class="kd">class</span> <span class="nc">C</span> <span class="p">{</span>

        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 静态成员内部类</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Monkey</span> <span class="p">{</span>
        <span class="n">String</span> <span class="n">name</span><span class="p">;</span>

        <span class="kd">public</span> <span class="nf">Monkey</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">}</span>

        <span class="kd">public</span> <span class="nf">Monkey</span><span class="p">(</span><span class="n">String</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">climb</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;猴子爬树&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 非静态成员内部类</span>
    <span class="kd">class</span> <span class="nc">Bird</span> <span class="p">{</span>
        <span class="n">String</span> <span class="n">name</span><span class="p">;</span>

        <span class="kd">public</span> <span class="nf">Bird</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">}</span>

        <span class="kd">public</span> <span class="nf">Bird</span><span class="p">(</span><span class="n">String</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sing</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;我是一只小小小小鸟~~~&quot;</span><span class="p">);</span>
            <span class="n">Zoo</span><span class="p">.</span><span class="na">this</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">display</span><span class="p">(</span><span class="n">String</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
            <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="p">);</span> <span class="c1">// 内部属性</span>
            <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Zoo</span><span class="p">.</span><span class="na">this</span><span class="p">.</span><span class="na">name</span><span class="p">);</span> <span class="c1">// 外部属性</span>

        <span class="p">}</span>
    <span class="p">}</span>


    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 局部内部类-方法</span>
        <span class="kd">class</span> <span class="nc">A</span> <span class="p">{</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;动物吃东西&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id31">
<h3><span class="section-number">10.7.3. </span>如何在成员内部类中调用外部类的结构？<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h3>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Person</span><span class="p">{</span>
	<span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;小明&quot;</span><span class="p">;</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">(){</span>
<span class="p">}</span>
<span class="c1">//非静态成员内部类</span>
	<span class="kd">class</span> <span class="nc">Bird</span><span class="p">{</span>
		<span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;杜鹃&quot;</span><span class="p">;</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">display</span><span class="p">(</span><span class="n">String</span> <span class="n">name</span><span class="p">){</span>
			<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">name</span><span class="p">);</span><span class="c1">//方法的形参</span>
			<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="p">);</span><span class="c1">//内部类的属性</span>
			<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">Person</span><span class="p">.</span><span class="na">this</span><span class="p">.</span><span class="na">name</span><span class="p">);</span><span class="c1">//外部类的属性</span>
		<span class="c1">//Person.this.eat();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id32">
<h3><span class="section-number">10.7.4. </span>局部内部类的使用<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h3>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="c1">//返回一个实现了Comparable接口的类的对象</span>
<span class="kd">public</span> <span class="n">Comparable</span> <span class="nf">getComparable</span><span class="p">(){</span>

    <span class="c1">//创建一个实现了Comparable接口的类:局部内部类</span>
    <span class="c1">//方式一：		</span>
    <span class="kd">class</span> <span class="nc">MyComparable</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="p">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="p">(</span><span class="n">Object</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>			
    <span class="p">}</span>

    <span class="k">return</span> <span class="k">new</span> <span class="n">MyComparable</span><span class="p">();</span>

    <span class="c1">//方式二：</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Comparable</span><span class="p">(){</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="p">(</span><span class="n">Object</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">};</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h3><span class="section-number">10.7.5. </span><strong>成员内部类和局部内部类，在编译以后，都会生成字节码文件。</strong><a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>成员内部类：外部类$内部类名.class</p></li>
<li><p>局部内部类：外部类$数字 内部类名.class</p></li>
</ul>
</div>
</div>
<div class="section" id="native">
<h2><span class="section-number">10.8. </span>关键字:<code class="docutils literal notranslate"><span class="pre">native</span></code><a class="headerlink" href="#native" title="永久链接至标题">¶</a></h2>
<div class="section" id="id34">
<h3><span class="section-number">10.8.1. </span>native 关键的理解<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><p>使用 native 关键字说明这个方法是原生函数，也就是这个方法是用 <code class="docutils literal notranslate"><span class="pre">C/C++</span></code>等非<code class="docutils literal notranslate"><span class="pre">Java</span> </code>语言实现的，并且被编译成了 <code class="docutils literal notranslate"><span class="pre">DLL</span></code>，由 <code class="docutils literal notranslate"><span class="pre">java</span></code> 去调用。</p></li>
</ul>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">java</span></code> 使用起来非常方便，然而有些层次的任务用<code class="docutils literal notranslate"> <span class="pre">java</span></code> 实现起来不容易，或者我们对程序的效率很在意时，问题就来了。例如：有时 <code class="docutils literal notranslate"><span class="pre">java</span> </code>应用需要与<code class="docutils literal notranslate"> <span class="pre">java</span></code> 外面的环境交互。这是本地方法存在的主要原因，你可以想想 java 需要与一些底层系统如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解 <code class="docutils literal notranslate"><span class="pre">java</span></code> 应用之外的繁琐的细节。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">native</span></code> 声明的方法，对于调用者，可以当做和其他 <code class="docutils literal notranslate"><span class="pre">Java</span> </code>方法一样使用
一个<code class="docutils literal notranslate"><span class="pre">native</span> <span class="pre">method</span> </code>方法可以返回任何<code class="docutils literal notranslate"> <span class="pre">java</span></code> 类型，包括非基本类型，而且同样可以进行异常控制。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">native</span> <span class="pre">method</span></code> 的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。<code class="docutils literal notranslate"><span class="pre">JVM</span></code> 将控制调用本地方法的所有细节。</p></li>
<li><p>如果一个含有本地方法的类被继承，子类会继承这个本地方法并且可以用<code class="docutils literal notranslate"> <span class="pre">java</span></code>语言重写这个方法（如果需要的话）。</p></li>
</ul>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="throw.html" class="btn btn-neutral float-right" title="11. 异常" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="oopsecond.html" class="btn btn-neutral float-left" title="9. 面对对象-中" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 版权所有 2020, Frenude

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>